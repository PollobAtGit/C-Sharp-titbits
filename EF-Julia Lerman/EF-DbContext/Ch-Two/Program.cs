using Ch_Two.DAL;
using Model;
using System;
using System.Data.Entity;
using System.Linq;

namespace Ch_Two
{
    class Program
    {
        readonly static Action<object> cl = (object x) => Console.WriteLine(x);

        static void Main(string[] args)
        {
            //Example_Prior_2_7();
            //Example_2_17();
            //Example_2_20();
            //Example_2_21();
            Example_2_22();
        }

        private static void Example_2_22()
        {
            using (var context = new BreakAwayContext())
            {
                context.Destinations.Local.CollectionChanged += TrackFetchEvent;

                context.Destinations.First(x => x.Country == "aus");// Prints AUS because event handler is listening to fetch event
                context.Destinations.First(x => x.Country == "bd");// Prints BD because event handler is listening to fetch event

                // POI: Add events are also tracked by CollectionChanged
                // POI: CollectionChanged tracks add event even if data is added to Local or also even if it's added to DbSet<T>
                context.Destinations.Local.Add(new Destination { Country = "Bulgeria" });

                // POI: All validations are performed in DB level. So it's ok not to provide Name which rquired by the way
                context.Destinations.Add(new Destination { Country = "UK" });

                // POI: Adding garbage will not crash until context reaches to DB but that's not case of Remove()
                // POI: Remove() will crash if no valid value is not found with that id
                context.Destinations.Remove(context.Destinations.Find(2));

                // POI: This addition of destination will not be listened as addition is done on a List generated by ToList() 
                // which is a seperate list
                context.Destinations.Local.ToList().Add(new Destination { Country = "BRA" });
            }
        }

        private static void TrackFetchEvent(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            if (e.NewItems == null && e.OldItems == null) return;
            if (e.NewItems != null && e.OldItems == null)
            {
                cl("[DB]: Adding " + e.NewItems.Cast<Destination>().First().Country);
                return;
            }

            cl("[DB]: Removing " + e.OldItems.Cast<Destination>().First().Country);
        }

        private static void Example_2_21()
        {
            using (var context = new BreakAwayContext())
            {
                var country = "bd";

                context.Destinations.Load();

                // POI: Filtering on Local() enforces .NET (C#) rules because SQL to Object uses different LINQ provider
                cl("Local Count (Filter By 'bd'): " + context.Destinations.Local.Where(x => x.Country == country).Count());// 0

                // POI: Filtering on DbSet<T> enforces SQL Server rules because SQL to Entities uses different LINQ provider
                cl("DB Count (Filter By 'bd'): " + context.Destinations.Where(x => x.Country == country).Count());// 0
            }
        }

        // POI: Local keeps the cumulative queried/added/deleted data
        // POI: Local should be used carefully
        // POI: Local is faster because we are using cached data
        private static void Example_2_20()
        {
            using (var context = new BreakAwayContext())
            {
                cl("Local Count (Init): " + LocalDestinationsCount(context));// 0
                cl("DB Count: " + DBDestinationsCount(context));// 4

                // POI: Load() is a extnsion method on IQuerable so it can be used to load data in memory
                context.Destinations.Where(x => x.Country == "BD").Load();// Load 2 record

                DisplayAllDestinationsCache(context);// Prints id 2 & 3

                cl("Local Queried Data: ");

                // POI: No records returned because Local doesn't contain any records with AUS
                context.Destinations.Local.Where(x => x.Country == "AUS").ToList().ForEach(x => cl(x));

                // POI: Local/Cache now contains only the data queried. So filtering condition matters here
                cl("Local Count (On IQuerable = BD): " + LocalDestinationsCount(context));// 2

                context.Destinations.Where(x => x.Country == "AUS").Load();// Load 1 record

                // POI: Local/Cache count is = previous records count + new query records count
                cl("Local Count (On IQuerable = AUS): " + LocalDestinationsCount(context));// 3

                // POI: Exception of duplicate key will not be thrown in memory rather in DB level
                context.Destinations.Add(new Destination { DestinationId = 2 });

                cl("Local Count (Add Duplicate): " + LocalDestinationsCount(context));// 4

                DisplayAllDestinationsDB(context, x => { });// Load 4 records from DB

                // POI: Count != previous count + current query count because duplicates are removed (for DB queried data)
                cl("Local Count (Full Load): " + LocalDestinationsCount(context));// 5
            }
        }

        private static void Example_2_17()
        {
            using (var context = new BreakAwayContext())
            {
                cl("Local Count: " + LocalDestinationsCount(context));// 0

                // POI: Invoking Count on DBSet(...) doesn't load data to local cache
                // POI: Count upon DbSet<T> only requests a DB Count(*) query
                cl("DB Count: " + DBDestinationsCount(context));// 2
                cl("Local Count: " + LocalDestinationsCount(context));// 0

                // POI: Loading data
                //DisplayAllDestinationsDB(context, x => { });
                LoadDestinationsDB(context);

                cl("Local Count: " + LocalDestinationsCount(context));// 2
            }
        }

        private static void Example_Prior_2_7()
        {
            using (var context = new BreakAwayContext())
            {
                var notFoundMsg = "Destination Not Found";

                // POI: Destination is not found because Local... is not initialized (!). Data has never been asked for (till now)
                var xDDestination = context.Destinations.Local.SingleOrDefault(x => x.Name == "xD");
                cl("Current Local Data Count: " + LocalDestinationsCount(context));

                cl(xDDestination == null ? notFoundMsg : xDDestination.ToString());

                // POI: Data is being asked for now. So Local... will be initialized after this statement
                foreach (var destination in context.Destinations)
                {
                    cl(destination.Name);
                }

                cl("");

                // POI: This Destination will not be shown retrieved when Select(...) 'ing via DbSet<T> because DbSet<T> by default 
                // goes to DB but this destination is not in DB still
                var newDst = context.Destinations.Add(new Destination { Name = "aTy" });

                DisplayAllDestinationsDB(context);

                cl("");

                context
                    .Destinations
                    .ToList()

                    // POI: As expected this OrderBy doesn't translate in SQL
                    .OrderBy(x => x.Name)
                    .ToList()
                    .ForEach(x => cl(x));

                cl("Enter Id:");
                var id = int.Parse(Console.ReadLine());

                // POI: If id is 0 then context will be able to find a destination with that id because Find(...) searches for that 
                // id in in-memory (local) data also
                // POI: Find(...) s pool of interest = DB + [local storage that haven't been saved in DB yet]
                // POI: Find(...) depends on [Key] annotation defined for that model
                // POI: Model can have composite key. In that case Find(..., ...) will take multiple arguments & will use the combination 
                // of those values to identify the content
                cl(context.Destinations.Find(id) == null ? notFoundMsg : context.Destinations.Find(id).ToString());

                cl("Enter Name To Search For:");

                var strName = Console.ReadLine();

                // POI: Single(...) or SingleOrDefault(...) goes to DB to search for data. It's not similar to Find(...) which takes 
                // local memory into account
                // POI: Single(...)/SingleOrDefault(...) doesn't take TOP 1 rows rather TOP 2 (SELECT TOP (2)) rows because if the sequence 
                // contains more than one element then exception is thrown. To determine how many rows matched the result TOP 2 
                // rows are required to be fetched
                cl(context.Destinations.SingleOrDefault(x => x.Name == strName));

                // POI: Unsaved Dstination will be available here
                // POI: This approach is better then saving data as using ..ToList() because that stored data is not required 
                // to be passed as argument etc.
                cl(context.Destinations.Local.SingleOrDefault(x => x.Name == strName));

                cl("Current Local Data Count: " + LocalDestinationsCount(context));
                cl("Current DB Data Count: " + DBDestinationsCount(context));

                cl("Enter Id to Delete Destination");

                var iD = int.Parse(Console.ReadLine());

                // POI: Similar to Add(...) Remove(...) trackes the changes in Local cache first
                context.Destinations.Remove(context.Destinations.Find(iD));

                DisplayAllDestinationsDB(context);

                cl("");

                DisplayAllDestinationsCache(context);

                cl("");
                cl("Current Local Data Count: " + LocalDestinationsCount(context));
            }
        }

        // POI: Local tracks all data. Removed data, added data, changed data etc.
        private static void DisplayAllDestinationsCache(BreakAwayContext context)
        {
            context
                .Destinations
                .Local

                // POI: This OrderBy(...) translates into SQL because DbSet<T> implements IQuerable<T>
                .OrderBy(x => x.Name)
                .ToList()
                .ForEach(x => cl(x));
        }

        private static void LoadDestinationsDB(BreakAwayContext context)
        {
            // POI: Load() loads all data from DB to Local cache without iteration over DbSet<T>
            // POI: Load() is a extension method of IQuerable not DbSet<T>. So it's not specific to Entity Framework rather LINQ in general
            context.Destinations.Load();
        }

        private static void DisplayAllDestinationsDB(BreakAwayContext context, Action<Destination> func)
        {
            context
                .Destinations

                // POI: This OrderBy(...) translates into SQL because DbSet<T> implements IQuerable<T>
                .OrderBy(x => x.Name)
                .ToList()
                .ForEach(x => func(x));
        }

        private static void DisplayAllDestinationsDB(BreakAwayContext context)
        {
            context
                .Destinations

                // POI: This OrderBy(...) translates into SQL because DbSet<T> implements IQuerable<T>
                .OrderBy(x => x.Name)
                .ToList()
                .ForEach(x => cl(x));
        }

        private static int LocalDestinationsCount(BreakAwayContext context) => context.Destinations.Local.Count();
        private static int DBDestinationsCount(BreakAwayContext context) => context.Destinations.Count();
    }
}
